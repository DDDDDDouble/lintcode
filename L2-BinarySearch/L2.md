10个basic+9optional+3related
##basic：
2. Last Position of Target
1. First Position of Target
3. sqrt(x)

##optional


##related

##题解（BinarySearch 问题，有模板）
模板：(Last Position of Target)
对这道题而言其中很重要的一句话 
`if(nums[mid] == target) start=mid; `
//this means recursively call binary search on the right half of the array including nums[mid]
正常的二分查找，这里一般就返回 mid 了 
```
public class Solution {
    public int lastPosition(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int start = 0, end = nums.length - 1;
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                start = mid;
            } else if (nums[mid] < target) {
                start = mid;
                // or start = mid + 1
            } else {
                end = mid;
                // or start = mid - 1
            }
        }       
        if (nums[start] == target) {
            return start;
        }
        return -1;
    }
}
```
####1. Last Position of Target
这种查找类问题，第一反应一般都是个O(n) 的算法，遍历查找，但是运行一次说超时，就可以想到这里用二分查找
自己写的代码和答案不太一样，if判断哪里还是强行想返回mid，所以加上了很多判定条件，不如上面模板给的方法好。
再写一次这个题的重点：`if(nums[mid] == target) start=mid; `，this means recursively call binary search on the right half of the array including nums[mid]
```
public int lastPosition(int[] nums, int target) {
       if(nums==null||nums.length==0||target<0||target>nums[nums.length-1]) return -1;
       int start = 0, end = nums.length-1;
       while(start<end){
           int mid = start+(end-start)/2;
           if(nums[mid]==target&&(mid==(nums.length-1)||nums[mid+1]!=target)) return mid;
           else if (nums[mid]>target) end = mid-1;
           else start = mid+1;
       }
       if (nums[end] == target) {
            return end;
        }
        if (nums[start] == target) {
            return start;
        }
        return -1;
    }
```

####2. First Position of Target
如果理解了上一题模板代码那种写法，这题非常简单，只需要变动一句话，
上题找last position，我们找到target后向后去找后面的，
这题找first position，我们找到target后向前找前面的，
```
public int binarySearch(int[] nums, int target) {
    if(nums==null||nums.length==0||target<0||target>nums[nums.length-1]) return -1;
    int start = 0, end = nums.length-1;
    while(start<end){
        int mid = start+(end-start)/2;
        //下面两句可以合并成 if (nums[mid]>=target) end = mid;
        if(nums[mid]==target) end=mid;
        else if (nums[mid]>target) end = mid-1;
        else start = mid+1;
    }
    if (nums[start] == target) {
        return start;
    }
    return -1;
}
```

####First Bad version/
看题应该会立刻想到二分查找，另外这个思想和和438中sliding window的思路有有一点类似.
这个题需要搞清楚两点：
1. 如果mid不是，那mid前都不是，查找mid后面，如果mid是，查找mid前
2. 返回谁，我是举了个例子试了一下，不过从if这句可以看出，返回start
3. 注意start=1，从1开始
！！注意这个题的二分考点，跟上面一毛一样，上面核心代码，注释里的合并版就是这题的解，
！！两题的区别在于返回值，version或者说bad version是连续存在的，有3必有2，但target可能不存在，所以version直接返回start，target要考虑不存在的情况下返回-1，其他情况返回start
```
public int findFirstBadVersion(int n) {
    int start =1;
    int end = n;
    while(start<end){
        int mid = start+(end-start)/2;
        if( SVNRepo.isBadVersion(mid) ){
            end = mid;
        } 
        else start = mid+1;
    }
    return start;
}
```

####sqrt(x)
看着超级简单，结果被这个题气炸，有两个坑，
1. long 都用int的话999999反正一个大数字会报错，用long只需要注意一点，返回值记得强转回来
2. 返回值，看return那句吧，因为例子给的都是直接切掉小数部分的结果，相当于向前取了小的数，所以最后返回的时候判断一下，别问我怎么想到的，我想不到。。。记住吧，二分法的返回值幺蛾子真多
```
 public int sqrt(int x) {
    long start = 1;
    long end = x;
    while(start<end){
        long mid = start+(end-start)/2;
        if(mid*mid==x) return (int)mid;
        else if(mid*mid>x) end = mid-1;
        else start = mid+1;
    }
    return start*start>x?(int)(start-1):(int)start;
}
```