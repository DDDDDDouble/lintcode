10个basic+9optional+2related

##before basic:
1. preorder,stack+divide&conquer
2. inorder,stack
3. postorder,stack(hard)+divide&conquer
4. About stack: stack.push()/stack.add()这几个题都用的add，个人认为push比较好

divide-conquer method for preorder and postorder are very similiar, for preorder, we add root first, then root.left,root.right, for postorder, we add root.left,root.right first, then root.



##basic：
2. Maximum Depth of Binary Tree
1. Binary Tree Paths
3. Minimum Subtree
4. Balanced Binary Tree

5. Find Minimum in Rotated Sorted Array
6. Find Peak Element
7. Search in Rotated Sorted Array
3. sqrt(x)
9. Wood Cut
10. Copy Books


##optional


##related

##题解（大部分binary tree问题用divide-conquer解决）
####Maximum Depth of Binary Tree
分析整棵树在该问题上的结果 和左右儿子在该问题上的结果之间的联系是什么，左右子树的max depth中，大的那个+1，就是当前root的max depth中，大的那个
divide-conquer方法写出来代码很直观很简明
```
public int maxDepth(TreeNode root) {
    int dep  = 0;
    // null or leaf
    if (root == null) return dep;
    // Divide
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    // Conquer
    return Math.max(left,right)+1;
}
```

####Binary Tree Paths
两种方法都是递归，所以都要先判断root==null和左右节点==null的情况，做适合的返回
1. divide-conquer: 类似于先找左右子树的path，然后和root分别组成path，所以上面说的左右节点==null的情况要把当前节点加入，左右子树的path也通过该方法获得，最后把左子树的所有path遍历都加入root,右边同理，得到path
2. traverse:通常是站在root，向左右走，所以root先加入path，走到尽头的路上一次加入节点，最后，左右节点==null的时候，要把当前已生成的path加入到结果集中。
```
//divide-conquer
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> paths = new ArrayList<>();
        if(root==null) return paths;
        if(root.left == null && root.right == null){
            paths.add(root.val+"");
            return paths;
        }
        List<String> left =binaryTreePaths(root.left);
        List<String> right =binaryTreePaths(root.right);
        //left==[], skip for()
        for(String l : left){
            paths.add(root.val+"->"+l);
        }
        for(String r : right){
            paths.add(root.val+"->"+r);
        }
        return paths;
    }

    // helper-traverse
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if(root==null) return result;
        helper(root,String.valueOf(root.val),result);
        return result;
    }
    private void helper(TreeNode root, String path, List<String> result){
        if(root==null) return;
        if(root.left == null && root.right == null){
            result.add(path);
        }
        if(root.left!=null){
            helper(root.left, path+"->"+String.valueOf(root.left.val), result);
        }
        if(root.right!=null){
            helper(root.right, path+"->"+String.valueOf(root.right.val), result);
        }
    }
```

#### Minimum Subtree
1. traverse+divide-conquer 因为这里要求的是min，所有需要一个全局变量来当参照，所以创建了一个node表示当前min的node，一个min，每次遇到比当前min的，min和sub node 一起更新
2. only divide-conquer, 大概的代码过程很好写，但还是老问题，取min比较的是 sum of val ，需要返回的是node，所以需要另一个Result类来帮助
```
public class Solution {
    private TreeNode sub = null;
    private int subSum = Integer.MAX_VALUE;

    public TreeNode findSubtree(TreeNode root) {
        helper(root);
        return sub;
    }
    private int helper(TreeNode root){
        if(root==null) return 0;
        int sum = helper(root.left)+helper(root.right)+root.val;
        if(sum<subSum){
            subSum = sum;
            sub=root;
        }
        return sum;
    }
}
```

####Balanced Binary Tree
首先看定义：左子树是平衡的，右子树是平和的，左右高度差距不大于1，或者说高度是想同的，三个条件

1. 第一种解法看起来代码短小精悍，很好，但这个解法最难的地方应该是maxdepth这个方法的返回值部分，最后如果遍历到目前为止，是balanced的话，记录当前的height就是通过return语句做的。应该是因为这里只要求返回Boolean，所以可以省个Result类
2. Result类实现，两种解法的思路其实就一样，写过第一种，第二种就可以自己写出来了，需要注意一点的是当 unbalanced， maxdepth怎么表示合适，我选了0，也可以是-1，可以通过交流来选择合适的值。
```
public class Solution {
    public boolean isBalanced(TreeNode root) {
        return maxDepth(root)!=-1;
    }
    private int maxDepth(TreeNode root){
        if(root==null) return 0;
    }
    
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    if(left==-1 || right==-1 || Math.abs(left-right)>1){
        return -1;
    }
    return Max.max(left,right)+1;
}
```
```
public class Solution {
    class Result{
        int maxdepth;
        boolean isBalanced;
        public Result(boolean isBalanced, int maxdepth){
            this.isBalanced = isBalanced;
            this.maxdepth = maxdepth;
        }
    }

    public boolean isBalanced(TreeNode root) {
        return helper(root).isBalanced;
    }
    private Result helper(TreeNode root){
        if(root==null) return new Result(true,0);
        Result left = helper(root.left);
        Result right = helper(root.right);
        if(!left.isBalanced || !right.isBalanced || Math.abs(left.maxdepth-right.maxdepth)>1){
            return new Result(false,0);
        }
        return new Result(true,Math.max(left.maxdepth,right.maxdepth)+1);
    }
}
```